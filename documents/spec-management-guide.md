# Spec管理ガイド

> OwlNestプロジェクトのrequirements.md、design.md、tasks.mdの管理方法

## 📋 目次

1. [Specドキュメントの概要](#specドキュメントの概要)
2. [各ドキュメントの役割](#各ドキュメントの役割)
3. [Specの作成・更新フロー](#specの作成更新フロー)
4. [ドキュメント更新の依頼方法](#ドキュメント更新の依頼方法)
5. [タスク実行の管理](#タスク実行の管理)
6. [ベストプラクティス](#ベストプラクティス)

---

## Specドキュメントの概要

### Specとは
Specは「Specification（仕様書）」の略で、機能開発を体系的に進めるための3つのドキュメントセットです：

1. **requirements.md** - 要件定義書
2. **design.md** - 設計書
3. **tasks.md** - 実装タスク一覧

### Specの目的
- **要件の明確化**: 何を作るかを明確にする
- **設計の文書化**: どのように作るかを設計する
- **実装の計画化**: 具体的な作業を計画する
- **進捗の可視化**: 実装状況を追跡する
- **知識の共有**: チーム内での情報共有

### Specの配置場所
```
.kiro/specs/[feature-name]/
├── requirements.md    # 要件定義書
├── design.md         # 設計書
└── tasks.md          # タスク一覧
```

---

## 各ドキュメントの役割

### 1. requirements.md（要件定義書）

#### 目的
- **何を作るか**を明確にする
- ユーザーのニーズと期待を整理する
- 機能の境界と制約を定義する

#### 構成要素
```markdown
# Requirements Document

## Introduction
[機能の概要と背景]

## Requirements

### Requirement 1
**User Story:** As a [role], I want [feature], so that [benefit]

#### Acceptance Criteria
1. WHEN [event] THEN [system] SHALL [response]
2. IF [precondition] THEN [system] SHALL [response]

### Requirement 2
[同様の構成で要件を列挙]
```

#### 更新タイミング
- 新機能の企画時
- 要件変更時
- ユーザーフィードバック反映時
- 仕様の見直し時

### 2. design.md（設計書）

#### 目的
- **どのように作るか**を設計する
- アーキテクチャと技術選択を文書化する
- 実装の指針を提供する

#### 構成要素
```markdown
# Design Document

## Overview
[設計の概要]

## Architecture
[システムアーキテクチャ]

## Components and Interfaces
[コンポーネント設計]

## Data Models
[データ構造設計]

## Error Handling
[エラー処理方針]

## Testing Strategy
[テスト戦略]
```

#### 更新タイミング
- 技術選択の変更時
- アーキテクチャの見直し時
- 新しい技術要件の追加時
- パフォーマンス要件の変更時

### 3. tasks.md（タスク一覧）

#### 目的
- **具体的な作業**を計画する
- 実装の進捗を管理する
- 作業の優先順位を明確にする

#### 構成要素
```markdown
# Implementation Plan

- [ ] 1. Set up project structure
  - Create directory structure
  - Define interfaces
  - _Requirements: 1.1_

- [ ] 2. Implement core functionality
- [ ] 2.1 Create data models
  - Write TypeScript interfaces
  - Implement validation
  - _Requirements: 2.1, 3.3_

- [x] 2.2 Implement API endpoints
  - Create REST endpoints
  - Add error handling
  - _Requirements: 2.2_
```

#### 更新タイミング
- タスクの完了時
- 新しいタスクの追加時
- タスクの優先順位変更時
- 実装方針の変更時

---

## Specの作成・更新フロー

### 新規Spec作成フロー

#### Phase 1: Requirements作成
```
1. Kiroに要件定義を依頼
   「[機能名]の要件定義を作成してください」

2. 要件レビュー・修正
   - ユーザーストーリーの確認
   - 受け入れ基準の妥当性チェック
   - 要件の過不足確認

3. 要件承認
   「要件定義が完成しました。次は設計に進んでください」
```

#### Phase 2: Design作成
```
1. Kiroに設計書作成を依頼
   「requirements.mdを基に設計書を作成してください」

2. 設計レビュー・修正
   - アーキテクチャの妥当性確認
   - 技術選択の適切性チェック
   - 既存システムとの整合性確認

3. 設計承認
   「設計書が完成しました。次はタスク一覧を作成してください」
```

#### Phase 3: Tasks作成
```
1. Kiroにタスク一覧作成を依頼
   「design.mdを基にタスク一覧を作成してください」

2. タスクレビュー・修正
   - タスクの粒度確認
   - 依存関係の整理
   - 優先順位の調整

3. タスク承認
   「タスク一覧が完成しました。実装を開始できます」
```

### 既存Spec更新フロー

#### 要件変更時
```
1. 変更内容の整理
   - 何が変わるのか
   - なぜ変更が必要なのか
   - 影響範囲はどこか

2. requirements.md更新依頼
   「requirements.mdの[セクション]を[内容]に更新してください」

3. 関連ドキュメントの更新
   - design.mdへの影響確認
   - tasks.mdの調整
```

#### 実装完了時
```
1. タスクステータス更新
   「tasks.mdの[タスク番号]を完了に更新してください」

2. 実装内容の反映
   - design.mdの実装詳細更新
   - 新しい課題の記録

3. 次のタスクの確認
   「次に実行すべきタスクを教えてください」
```

---

## ドキュメント更新の依頼方法

### 基本的な更新依頼テンプレート

```markdown
【Spec更新依頼】[更新内容の概要]

## 📄 更新対象ファイル
- [ ] .kiro/specs/[feature-name]/requirements.md
- [ ] .kiro/specs/[feature-name]/design.md
- [ ] .kiro/specs/[feature-name]/tasks.md

## 🔄 更新内容

### [ファイル名] の更新
[具体的な更新内容]

## 📝 詳細な更新指示

### 新規追加する内容
```
[追加するマークダウンの内容]
```

### 修正する内容
**修正前:**
```
[現在の内容]
```

**修正後:**
```
[修正後の内容]
```

### 削除する内容
```
[削除する内容]
```

## 🎯 更新の理由
[なぜこの更新が必要なのか]

## ✅ 確認事項
- [ ] 実装内容との整合性
- [ ] 他のドキュメントとの一貫性
- [ ] バージョン情報の更新
```

### 具体的な更新依頼例

#### 1. 要件追加の依頼
```markdown
【Spec更新依頼】いいね機能に通知機能を追加

## 📄 更新対象ファイル
- [x] .kiro/specs/discussion-platform-enhancement/requirements.md

## 🔄 更新内容

### requirements.md の更新
Requirement 5として通知機能の要件を追加

## 📝 詳細な更新指示

### 新規追加する内容
```markdown
### Requirement 5

**User Story:** As a ユーザー, I want いいねされた時に通知を受け取りたい, so that 自分の投稿への反応を知ることができる

#### Acceptance Criteria
1. WHEN 自分の投稿にいいねされた THEN システムは通知を生成する
2. WHEN 通知が生成された THEN ユーザーは通知一覧で確認できる
3. IF ユーザーが通知設定をOFFにしている THEN 通知は生成されない
```

## 🎯 更新の理由
いいね機能実装後のユーザーフィードバックで通知機能の要望が多かったため

## ✅ 確認事項
- [x] 既存要件との整合性確認済み
- [ ] design.mdへの影響確認
- [ ] tasks.mdへの新規タスク追加
```

#### 2. タスク完了の更新依頼
```markdown
【Spec更新依頼】いいね機能実装完了に伴うタスク更新

## 📄 更新対象ファイル
- [x] .kiro/specs/discussion-platform-enhancement/tasks.md

## 🔄 更新内容

### tasks.md の更新
タスク3.2を完了済みに更新

## 📝 詳細な更新指示

### 修正する内容
**修正前:**
```markdown
- [ ] 3.2 Implement like functionality
  - Create LikeButton component
  - Add like API endpoints
  - _Requirements: 3.2_
```

**修正後:**
```markdown
- [x] ~~3.2 Implement like functionality~~ ✅ 2025-08-06完了
  - [x] ~~Create LikeButton component~~
  - [x] ~~Add like API endpoints~~
  - [x] ~~Add unit tests~~
  - _Requirements: 3.2_
```

## 🎯 更新の理由
いいね機能の実装が完了し、テストも通過したため

## ✅ 確認事項
- [x] 実装内容との整合性確認済み
- [x] テスト完了確認済み
- [ ] 次のタスクの優先順位確認
```

#### 3. 設計変更の更新依頼
```markdown
【Spec更新依頼】パフォーマンス改善に伴うアーキテクチャ更新

## 📄 更新対象ファイル
- [x] .kiro/specs/discussion-platform-enhancement/design.md
- [x] .kiro/specs/discussion-platform-enhancement/tasks.md

## 🔄 更新内容

### design.md の更新
データフェッチング戦略をTanStack Queryに変更

### tasks.md の更新
新しいタスク4.5を追加

## 📝 詳細な更新指示

### design.md の修正内容
**修正前:**
```markdown
## Data Fetching Strategy
- 基本的なfetch APIを使用
- ローディング状態は各コンポーネントで管理
```

**修正後:**
```markdown
## Data Fetching Strategy
- ~~基本的なfetch APIを使用~~ → **TanStack Query v5を使用**
- ~~ローディング状態は各コンポーネントで管理~~ → **統一されたキャッシュとローディング管理**
- 理由: パフォーマンス向上、キャッシュ機能、エラーハンドリングの統一

## Caching Strategy
- TanStack Query による自動キャッシュ
- staleTime: 5分、cacheTime: 10分
- 楽観的更新による UX 向上
```

### tasks.md の新規追加内容
```markdown
- [ ] 4.5 Implement TanStack Query integration
  - Install and configure TanStack Query
  - Migrate existing API calls to use queries
  - Add optimistic updates for like functionality
  - _Requirements: 3.1, 3.2_
```

## 🎯 更新の理由
パフォーマンステストでデータフェッチングの改善が必要と判明したため

## ✅ 確認事項
- [x] パフォーマンス要件との整合性確認済み
- [x] 既存実装への影響評価済み
- [ ] 新しいタスクの優先順位設定
```

---

## タスク実行の管理

### タスクの実行フロー

#### 1. 次のタスクの選択
```
質問例:
「[feature-name]の次に実行すべきタスクを教えてください」
「タスク2.1を実行したいのですが、準備はできていますか？」
```

#### 2. タスクの実行依頼
```
依頼例:
「タスク2.1『Create data models』を実行してください」
「requirements.mdとdesign.mdを参考に、タスク2.1を実装してください」
```

#### 3. 実行中のステータス更新
```
更新依頼例:
「タスク2.1を実行中に更新してください」
```

#### 4. 完了時のステータス更新
```
更新依頼例:
「タスク2.1が完了したので、tasks.mdを更新してください」
```

### タスクの優先順位管理

#### 高優先度タスク
- 他のタスクの前提となるタスク
- セキュリティに関わるタスク
- ユーザーに直接影響するタスク

#### 中優先度タスク
- 機能の核となるタスク
- パフォーマンスに関わるタスク
- テストの実装タスク

#### 低優先度タスク
- UI/UXの改善タスク
- ドキュメントの更新タスク
- リファクタリングタスク

### 依存関係の管理

#### 依存関係の確認
```
確認例:
「タスク3.2を実行する前に、タスク2.1と2.2が完了している必要がありますか？」
「タスク4.1の実行に必要な前提条件を教えてください」
```

#### 並行実行可能なタスク
```
確認例:
「タスク3.1と3.2は並行して実行できますか？」
「UI実装とAPI実装を同時に進めることは可能ですか？」
```

---

## ベストプラクティス

### ドキュメント作成のベストプラクティス

#### 1. 明確で具体的な記述
```
❌ 悪い例:
「ユーザーが使いやすい機能を作る」

✅ 良い例:
「ユーザーが3クリック以内で投稿にいいねできる機能を作る」
```

#### 2. 測定可能な基準
```
❌ 悪い例:
「高速に動作する」

✅ 良い例:
「いいねボタンクリックから表示更新まで0.5秒以内」
```

#### 3. 要件の追跡可能性
```
✅ 良い例:
tasks.mdの各タスクに対応する要件番号を記載
「_Requirements: 2.1, 3.3_」
```

### ドキュメント更新のベストプラクティス

#### 1. 変更履歴の記録
```markdown
## Change History
- 2025-08-06: v1.1 - いいね機能の要件追加
- 2025-08-01: v1.0 - 初版作成
```

#### 2. 影響範囲の明示
```markdown
## Impact Analysis
- requirements.md: 新規要件追加
- design.md: API設計の追加
- tasks.md: 新規タスク3件追加
```

#### 3. レビューポイントの明示
```markdown
## Review Points
- [ ] 既存要件との整合性
- [ ] 技術的実現可能性
- [ ] パフォーマンスへの影響
- [ ] セキュリティ要件の確認
```

### タスク管理のベストプラクティス

#### 1. 適切な粒度
```
❌ 粒度が大きすぎる:
「ユーザー管理機能を実装する」

✅ 適切な粒度:
「ユーザー登録APIエンドポイントを実装する」
「ユーザー登録フォームコンポーネントを作成する」
```

#### 2. 明確な完了条件
```
✅ 良い例:
- [ ] 2.1 Create User model
  - TypeScript interface を定義
  - バリデーション関数を実装
  - 単体テストを作成
  - _Requirements: 2.1_
```

#### 3. 定期的な進捗確認
```
週次確認例:
「今週完了したタスクと来週の予定を確認してください」
「ブロックされているタスクはありますか？」
```

### コミュニケーションのベストプラクティス

#### 1. 明確な依頼
```
❌ 曖昧な依頼:
「Specを更新してください」

✅ 明確な依頼:
「requirements.mdの要件3.2に通知機能の受け入れ基準を追加してください」
```

#### 2. 文脈の提供
```
✅ 良い例:
「いいね機能の実装が完了したので、tasks.mdのタスク3.2を完了済みに更新してください。
実装内容は以下の通りです：
- LikeButton コンポーネント作成済み
- API エンドポイント実装済み
- 単体テスト作成済み」
```

#### 3. フィードバックの提供
```
✅ 良い例:
「要件定義書を確認しました。
要件3.1の受け入れ基準が明確で実装しやすそうです。
要件3.3についてはパフォーマンス要件を追加していただけますか？」
```

---

## トラブルシューティング

### よくある問題と解決方法

#### 1. ドキュメント間の不整合
```
問題: requirements.mdとdesign.mdの内容が矛盾している

解決方法:
1. 不整合箇所の特定
2. 正しい内容の確認
3. 関連ドキュメントの一括更新依頼
```

#### 2. タスクの依存関係エラー
```
問題: 前提タスクが完了していないのに次のタスクを実行しようとした

解決方法:
1. 依存関係の確認
2. 前提タスクの完了状況確認
3. 実行順序の調整
```

#### 3. 要件の曖昧さ
```
問題: 要件が曖昧で実装方針が決まらない

解決方法:
1. 曖昧な箇所の特定
2. 具体的な受け入れ基準の追加
3. ユーザーストーリーの詳細化
```

### 緊急時の対応

#### 1. 重要なバグ発見時
```
対応手順:
1. 緊急タスクとしてtasks.mdに追加
2. 優先度を最高に設定
3. 関連する実装タスクを一時停止
4. バグ修正完了後に通常タスクを再開
```

#### 2. 要件の大幅変更時
```
対応手順:
1. 変更の影響範囲を評価
2. requirements.mdの大幅更新
3. design.mdの見直し
4. tasks.mdの再構成
5. 実装済み部分の調整
```

---

## チェックリスト

### Spec作成時チェックリスト
- [ ] 要件が明確で具体的である
- [ ] 受け入れ基準が測定可能である
- [ ] 設計が要件を満たしている
- [ ] タスクが適切な粒度である
- [ ] 依存関係が明確である
- [ ] 優先順位が設定されている

### Spec更新時チェックリスト
- [ ] 更新理由が明確である
- [ ] 影響範囲が特定されている
- [ ] 関連ドキュメントとの整合性が保たれている
- [ ] 変更履歴が記録されている
- [ ] レビューが完了している

### タスク実行時チェックリスト
- [ ] 前提条件が満たされている
- [ ] 要件と設計を理解している
- [ ] 完了条件が明確である
- [ ] テスト計画が立てられている
- [ ] 進捗が適切に更新されている

---

**最終更新**: 2025-08-06  
**バージョン**: 1.0  
**作成者**: OwlNest開発チーム